---
title: "Asto sandbox"
author: "Itay Feldman"
---
```{python}
# Imports & setup
import numpy as np
import pandas as pd
import astropy.units as u
import plotly.express as px
import plotly.graph_objects as go

from astropy.coordinates import SkyCoord
from astropy.io import fits
from astropy.stats import sigma_clipped_stats, mad_std
from dataclasses import dataclass
from photutils.segmentation import detect_sources, deblend_sources, SegmentationImage, SourceCatalog
from photutils.background import Background2D, MedianBackground


PIXEL_SCALE = 0.04  # arcsec/pixel

@dataclass
class AstroImage:
    data: np.ndarray
    header: fits.Header
    band: str = ""
    segm: SegmentationImage = None
    catalog: SourceCatalog = None

```

# Data Prep
Start by reading the 4 fits files for the 4 filters
```{python}
# Load the FITS file
files = {
    "b": "./fits/b.fits",
    "i": "./fits/i.fits",
    "u": "./fits/u.fits",
    "v": "./fits/v.fits",
}

def adjust_data(data, threshold_percentile=99):
    """Remove black/low-value edges from image"""
    # Just trust me bro
    data = data[120:, 90:]
    data = data[:, ::-1]  # flip x&y (this is how the image is)
    return data

def read_fits(file_path):
    hdul = fits.open(file_path)
    data = hdul[0].data
    header = hdul[0].header
    hdul.close()
    # FIX ENDIANNESS FIRST before any processing!
    if data.dtype.byteorder == '>':
        data = data.view(data.dtype.newbyteorder()).byteswap()
    # Crop black edges & rotate
    data = adjust_data(data)
    hdul.close()
    return data, header

images: list[AstroImage] = []
for band, file in files.items():
    data, header = read_fits(file)

    images.append(AstroImage(data=data, header=header, band=band))
    print(f"Loaded {band} band - shape: {data.shape}")

# Read planet mask
data, header = read_fits("./data/planet_mask2.fits")
planet_mask = AstroImage(data=data, header=header)

```


Now we want source detection and cataloging

```{python}
# Prepare the mask once (True = mask out, False = keep)
mask = planet_mask.data.astype(bool)

for image in images:
    # Subtract background for better detection
    bkg_estimator = MedianBackground()
    bkg = Background2D(image.data, (50, 50), filter_size=(3, 3), bkg_estimator=bkg_estimator)
    data_sub = image.data - bkg.background
    
    # Detect sources with proper threshold
    mean, median, std = sigma_clipped_stats(data_sub, sigma=3.0)
    threshold = median + (3 * std)
    
    image.segm = detect_sources(
        data_sub,
        threshold,
        npixels=50,
        mask=mask  # Apply mask DURING detection
    )
    
    # Also remove any segments that overlap with masked regions
    if image.segm is not None:
        # Get unique segment labels that overlap with the mask
        masked_labels = np.unique(image.segm.data[mask])
        masked_labels = masked_labels[masked_labels != 0]  # Exclude background
        
        # Remove those segments
        image.segm.remove_labels(masked_labels)
    
    image.catalog = SourceCatalog(data_sub, image.segm)
    print(f"Band {image.band}: detected {len(image.catalog)} sources (after masking)")
```

Display sources
```{python}
i = 3  # Change this to view different bands (0=b, 1=i, 2=u, 3=v)
sources = images[i].catalog.to_table()
img_data = images[i].data

print(f"Detected {len(sources)} sources in band {images[i].band}")
print(f"Source detection threshold: {threshold:.2f}")

# Use percentile-based contrast stretching (20% to 99%)
vmin, vmax = np.percentile(img_data, [20, 99])

fig = px.imshow(
    img_data, 
    color_continuous_scale='Greys_r',
    zmin=vmin,
    zmax=vmax,
    aspect='equal'
)

# Add detected source markers
fig.add_trace(
    go.Scatter(
        x=sources['xcentroid'],
        y=sources['ycentroid'],
        mode='markers',
        marker=dict(color='red', size=3, symbol='circle-open', line=dict(width=1)),
        name=f'Sources ({len(sources)})'
    )
)

fig.update_layout(
    title=f"Band {images[i].band} - {len(sources)} sources detected",
    width=900,
    height=900,
    coloraxis_colorbar=dict(title="Pixel Value")
)

print(f"Image stats: min={img_data.min():.1f}, max={img_data.max():.1f}, "
      f"median={np.median(img_data):.1f}, std={img_data.std():.1f}")
print(f"Display range: {vmin:.1f} to {vmax:.1f}")
fig.show()
```

Create a combined catalog across all bands
```{python}
# First, create individual band catalogs with positions and fluxes
band_catalogs = {}
for image in images:
    cat = image.catalog.to_table().to_pandas()
    cat['r_half_pix'] = image.catalog.fluxfrac_radius(0.5)
    # segment_flux on background-subtracted data = source-sky (like AstroImageJ)
    cat['source_sky'] = cat['segment_flux']  # Already background-subtracted from data_sub
    band_catalogs[image.band] = cat[['xcentroid', 'ycentroid', 'source_sky', 'r_half_pix']].copy()

# Cross-match sources across all bands using position matching
# Start with first band as reference
reference_band = 'b'
matched_sources = []

for idx, ref_source in band_catalogs[reference_band].iterrows():
    ref_x, ref_y = ref_source['xcentroid'], ref_source['ycentroid']
    
    # Try to find matching sources in all other bands (within 3 pixels)
    match_radius = 3.0  # pixels
    matches = {'xcentroid': ref_x, 'ycentroid': ref_y}
    r_half_values = [ref_source['r_half_pix']]
    
    matches[f'source_sky_{reference_band}'] = ref_source['source_sky']
    
    found_in_all_bands = True
    for band in ['i', 'u', 'v']:  # Other bands
        cat = band_catalogs[band]
        # Calculate distance to all sources in this band
        distances = np.sqrt((cat['xcentroid'] - ref_x)**2 + (cat['ycentroid'] - ref_y)**2)
        
        # Find closest match within radius
        if distances.min() < match_radius:
            closest_idx = distances.idxmin()
            matches[f'source_sky_{band}'] = cat.loc[closest_idx, 'source_sky']
            r_half_values.append(cat.loc[closest_idx, 'r_half_pix'])
        else:
            found_in_all_bands = False
            break
    
    # Only keep sources found in all 4 bands
    if found_in_all_bands:
        matches['r_half_pix'] = np.median(r_half_values)  # Use median across bands
        matched_sources.append(matches)

# Create clean dataframe with cross-matched sources
cross_matched_catalog = pd.DataFrame(matched_sources)

print(f"Cross-matched catalog has {len(cross_matched_catalog)} sources (present in all 4 bands)")
print(f"Original catalogs had: b={len(band_catalogs['b'])}, i={len(band_catalogs['i'])}, "
      f"u={len(band_catalogs['u'])}, v={len(band_catalogs['v'])} sources")
display(cross_matched_catalog)
print(cross_matched_catalog.columns)

```
