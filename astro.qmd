---
title: "Asto sandbox"
author: "Itay Feldman"
---
```{python}
# Imports & setup
import numpy as np
import pandas as pd
import astropy.units as u
import plotly.express as px
import plotly.graph_objects as go

from astropy.coordinates import SkyCoord
from astropy.io import fits
from astropy.stats import sigma_clipped_stats, mad_std
from dataclasses import dataclass
from photutils.segmentation import detect_sources, deblend_sources, SegmentationImage, SourceCatalog
from photutils.background import Background2D, MedianBackground

from classify import classify_galaxy


PIXEL_SCALE = 0.04  # arcsec/pixel

@dataclass
class AstroImage:
    data: np.ndarray
    header: fits.Header
    band: str = ""
    segm: SegmentationImage = None
    catalog: SourceCatalog = None
    bkg: Background2D = None  # Background object from photutils

```

# Data Prep
Start by reading the 4 fits files for the 4 filters
```{python}
# Load the FITS file
files = {
    "b": "./fits/b.fits",
    "i": "./fits/i.fits",
    "u": "./fits/u.fits",
    "v": "./fits/v.fits",
}

def adjust_data(data, threshold_percentile=99):
    """Remove black/low-value edges from image"""
    # Just trust me bro
    data = data[120:, 90:]
    data = data[:, ::-1]  # flip x&y (this is how the image is)
    return data

def read_fits(file_path):
    hdul = fits.open(file_path)
    data = hdul[0].data
    header = hdul[0].header
    hdul.close()
    # FIX ENDIANNESS FIRST before any processing!
    if data.dtype.byteorder == '>':
        data = data.view(data.dtype.newbyteorder()).byteswap()
    # Crop black edges & rotate
    data = adjust_data(data)
    hdul.close()
    return data, header

images: list[AstroImage] = []
for band, file in files.items():
    data, header = read_fits(file)

    images.append(AstroImage(data=data, header=header, band=band))
    print(f"Loaded {band} band - shape: {data.shape}")

# Read planet mask
data, header = read_fits("./data/planet_mask2.fits")
planet_mask = AstroImage(data=data, header=header)

```


Now we want source detection and cataloging

```{python}
# Prepare the mask once (True = mask out, False = keep)
mask = planet_mask.data.astype(bool)

for image in images:
    # Subtract background for better detection
    bkg_estimator = MedianBackground()
    bkg = Background2D(image.data, (50, 50), filter_size=(3, 3), bkg_estimator=bkg_estimator)
    data_sub = image.data - bkg.background
    
    # Store background object for error estimation
    image.bkg = bkg
    
    # Detect sources with proper threshold
    mean, median, std = sigma_clipped_stats(data_sub, sigma=3.0)
    threshold = median + (3 * std)
    
    image.segm = detect_sources(
        data_sub,
        threshold,
        npixels=50,
        mask=mask  # Apply mask DURING detection
    )
    
    # Also remove any segments that overlap with masked regions
    if image.segm is not None:
        # Get unique segment labels that overlap with the mask
        masked_labels = np.unique(image.segm.data[mask])
        masked_labels = masked_labels[masked_labels != 0]  # Exclude background
        
        # Remove those segments
        image.segm.remove_labels(masked_labels)
    
    image.catalog = SourceCatalog(data_sub, image.segm)
    print(f"Band {image.band}: detected {len(image.catalog)} sources (after masking)")
```

Display sources
```{python}
i = 3  # Change this to view different bands (0=b, 1=i, 2=u, 3=v)
sources = images[i].catalog.to_table()
img_data = images[i].data

print(f"Detected {len(sources)} sources in band {images[i].band}")
print(f"Source detection threshold: {threshold:.2f}")

# Use percentile-based contrast stretching (20% to 99%)
vmin, vmax = np.percentile(img_data, [20, 99])

fig = px.imshow(
    img_data, 
    color_continuous_scale='Greys_r',
    zmin=vmin,
    zmax=vmax,
    aspect='equal'
)

# Add detected source markers
fig.add_trace(
    go.Scatter(
        x=sources['xcentroid'],
        y=sources['ycentroid'],
        mode='markers',
        marker=dict(color='red', size=3, symbol='circle-open', line=dict(width=1)),
        name=f'Sources ({len(sources)})'
    )
)

fig.update_layout(
    title=f"Band {images[i].band} - {len(sources)} sources detected",
    width=900,
    height=900,
    coloraxis_colorbar=dict(title="Pixel Value")
)

print(f"Image stats: min={img_data.min():.1f}, max={img_data.max():.1f}, "
      f"median={np.median(img_data):.1f}, std={img_data.std():.1f}")
print(f"Display range: {vmin:.1f} to {vmax:.1f}")
fig.show()
```

Create a combined catalog across all bands
```{python}
# First, create individual band catalogs with positions and fluxes
band_catalogs = {}
for image in images:
    cat = image.catalog.to_table().to_pandas()
    cat['r_half_pix'] = image.catalog.fluxfrac_radius(0.5)
    # segment_flux on background-subtracted data = source-sky (like AstroImageJ)
    cat['source_sky'] = cat['segment_flux']  # Already background-subtracted from data_sub
    
    # Calculate source error like AstroImageJ: sqrt(source_counts + n_pixels * sigma_background^2)
    # Assuming gain ~ 1 for simplicity (typical for modern CCDs in ADU units)
    cat['source_error'] = np.sqrt(np.abs(cat['segment_flux']) + cat['area'] * image.bkg.background_rms_median**2)
    
    band_catalogs[image.band] = cat[['xcentroid', 'ycentroid', 'source_sky', 'source_error', 'r_half_pix']].copy()

# Cross-match sources across all bands using position matching
# Start with first band as reference
reference_band = 'b'
matched_sources = []

for idx, ref_source in band_catalogs[reference_band].iterrows():
    ref_x, ref_y = ref_source['xcentroid'], ref_source['ycentroid']
    
    # Try to find matching sources in all other bands (within 3 pixels)
    match_radius = 3.0  # pixels
    matches = {'xcentroid': ref_x, 'ycentroid': ref_y}
    r_half_values = [ref_source['r_half_pix']]
    
    matches[f'source_sky_{reference_band}'] = ref_source['source_sky']
    matches[f'source_error_{reference_band}'] = ref_source['source_error']
    
    found_in_all_bands = True
    for band in ['i', 'u', 'v']:  # Other bands
        cat = band_catalogs[band]
        # Calculate distance to all sources in this band
        distances = np.sqrt((cat['xcentroid'] - ref_x)**2 + (cat['ycentroid'] - ref_y)**2)
        
        # Find closest match within radius
        if distances.min() < match_radius:
            closest_idx = distances.idxmin()
            matches[f'source_sky_{band}'] = cat.loc[closest_idx, 'source_sky']
            matches[f'source_error_{band}'] = cat.loc[closest_idx, 'source_error']
            r_half_values.append(cat.loc[closest_idx, 'r_half_pix'])
        else:
            found_in_all_bands = False
            break
    
    # Only keep sources found in all 4 bands
    if found_in_all_bands:
        matches['r_half_pix'] = np.median(r_half_values)  # Use median across bands
        matched_sources.append(matches)

# Create clean dataframe with cross-matched sources
cross_matched_catalog = pd.DataFrame(matched_sources)

print(f"Cross-matched catalog has {len(cross_matched_catalog)} sources (present in all 4 bands)")
print(f"Original catalogs had: b={len(band_catalogs['b'])}, i={len(band_catalogs['i'])}, "
      f"u={len(band_catalogs['u'])}, v={len(band_catalogs['v'])} sources")
display(cross_matched_catalog.head())
# print(cross_matched_catalog.columns)

```


Now we create another dataframe with the relevant converted SEDs and errors
```{python}
# Conversion factors from source_sky (ADU) to microJy
conversion_factors = {
    'b': 8.8e-18,
    'i': 2.45e-18,
    'u': 5.99e-17,
    'v': 1.89e-18,
}
sed_data = []
for idx, row in cross_matched_catalog.iterrows():
    sed_entry = {'r_half_pix': row['r_half_pix'],
                 "xcentroid": row['xcentroid'], "ycentroid": row['ycentroid']}
    for band in ['b', 'i', 'u', 'v']:
        flux_adu = row[f'source_sky_{band}']
        error_adu = row[f'source_error_{band}']
        # Convert to microJy
        sed_entry[f'flux_{band}'] = flux_adu * conversion_factors[band]
        sed_entry[f'error_{band}'] = error_adu * conversion_factors[band]
    sed_data.append(sed_entry)
sed_catalog = pd.DataFrame(sed_data)
print(f"SED catalog has {len(sed_catalog)} sources")
display(sed_catalog.head())
```


Finally, we use this catalog to identify the redshift of each source
```{python}
for idx, row in sed_catalog.iterrows():
    # The order of the bands is important here
    fluxes = [row[f'flux_{band}'] for band in ['b', 'i', 'u', 'v']]
    errors = [row[f'error_{band}'] for band in ['b', 'i', 'u', 'v']]

    galaxy_type, redshift = classify_galaxy(fluxes, errors, spectra_path=R".\spectra\Spectra")

    sed_catalog.at[idx, 'redshift'] = redshift
    sed_catalog.at[idx, 'galaxy_type'] = galaxy_type

display(sed_catalog.head())
```